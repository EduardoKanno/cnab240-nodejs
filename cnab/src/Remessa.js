// Generated by CoffeeScript 2.1.1
(function() {
  var Joi, Remessa, Rules, Utils, _, expect, removeAccents;

  Rules = require('../../layout/Rules');

  Utils = require('./Utils');

  Joi = require('joi');

  expect = require('expect.js');

  _ = require('lodash');

  removeAccents = require('remove-accents');

  Remessa = (function() {
    var DETAIL, DETAIL2, FILE_HEADER, FILE_SECTIONS, FILE_TRAILING, LOT_HEADER, LOT_TRAILING;

    class Remessa {
      constructor(bank, type, deps) {
        var ref, ref1, ref2, ref3, ref4, rules;
        rules = (deps != null ? deps.Rules : void 0) || Rules;
        if (bank == null) {
          throw new Error('Bank is mandatory');
        }
        if (type == null) {
          throw new Error('Type is mandatory');
        }
        this.rules = {
          ArquivoHeader: rules[bank].ArquivoHeader,
          ArquivoTrailing: rules[bank].ArquivoTrailing,
          LoteHeader: (ref = rules[bank][type]) != null ? ref.LoteHeader : void 0,
          LoteTrailing: (ref1 = rules[bank][type]) != null ? ref1.LoteTrailing : void 0,
          Detail: (ref2 = rules[bank][type]) != null ? ref2.Detail : void 0,
          Detail2: (ref3 = rules[bank][type]) != null ? ref3.Detail2 : void 0
        };
        this.CONSTANTS = (ref4 = rules[bank][type]) != null ? ref4.Constants : void 0;
      }

      // TODO: add data, enum and range validations
      validateLenghts(rulesName, userValues) {
        var ref, ref1, ref2, rules, validation;
        if (rulesName == null) {
          throw new Error('RulesName is mandatory');
        }
        if (userValues == null) {
          throw new Error('UserValues is mandatory');
        }
        rules = _.reduce(this.rules[rulesName], function(rules, fieldConfig) {
          var rule;
          rule = Joi.string().max(fieldConfig.length);
          if (fieldConfig.required && (fieldConfig.default == null)) {
            rule = rule.required();
          }
          rules[fieldConfig.field] = rule;
          return rules;
        }, {});
        rules.section = Joi.string().optional();
        validation = (ref = Joi.validate(userValues, Joi.object(rules), {
          abortEarly: false
        })) != null ? (ref1 = ref.error) != null ? (ref2 = ref1.details) != null ? ref2.map(function(error) {
          return error.message;
        }) : void 0 : void 0 : void 0;
        if (!_.isEmpty(validation)) {
          throw new Error(validation);
        }
        return _.each(_.filter(this.rules[rulesName], 'default'), function(config) {
          if (config.default.toString().length !== config.length) {
            throw new Error(`${rulesName}.${config.field} length must be less than or equal to ${config.length} characters long`);
          }
        });
      }

      prepare(rulesName, validated) {
        var fieldConfig, key, rules, utils, value;
        utils = new Utils;
        rules = _.cloneDeep(this.rules[rulesName]);
        for (key in validated) {
          value = validated[key];
          fieldConfig = _.find(rules, {
            field: key
          });
          if (fieldConfig != null) {
            fieldConfig.value = value;
          }
        }
        // formats all fields to match the required length
        return _.map(rules, function(item) {
          var meaninglessChar;
          if ((item.default != null) && (item.value == null)) {
            // we consider that the default values already have the correct length
            return item;
          }
          // if there's no value (eg, non-required field with no default value)
          if (item.value == null) {
            meaninglessChar = item.type === 'alphanumeric' ? ' ' : '0';
            item.value = new Array(item.length).fill(meaninglessChar).join('');
          }
          // for now, when the field doesn't have a type, it defaults to numeric
          item.value = (item.type != null) && item.type === 'alphanumeric' ? utils.padString(item) : utils.padNumber(item);
          return item;
        });
      }

      // inserts the params into the 240b string, filling gaps where no values are passed
      build(prepared) {
        var base;
        base = Array(240);
        _.map(prepared, function(fieldConfig) {
          var args, fieldValue, ref, ref1;
          fieldValue = ((ref = fieldConfig.value) != null ? ref.toString() : void 0) || ((ref1 = fieldConfig.default) != null ? ref1.toString() : void 0);
          args = [fieldConfig.startPos, fieldConfig.length].concat(fieldValue.toString().split(''));
          return base.splice.apply(base, args).join('');
        });
        base.shift();
        // console.log 'Checking section size on build'
        // expect(base.length).to.be 240
        return base.join('');
      }

      process(userValues, fileSections, newLine = '\n') {
        var missingKeys, remessa, sections, valuesArr;
        if (FILE_SECTIONS == null) {
          FILE_SECTIONS = fileSections;
        }
        // let's test if all required file sections were given
        missingKeys = _.difference(FILE_SECTIONS, _.keys(userValues));
        if (!_.isEmpty(missingKeys)) {
          throw Error(`Missing file sections: ${missingKeys.join(', ')}`);
        }
        // now we'll put the section key into each values object...
        valuesArr = _.map(FILE_SECTIONS, function(section) {
          // the detail section could have several items
          if (section === DETAIL && _.isArray(userValues[section])) {
            return _.map(userValues[section], function(subsection) {
              subsection[0].section = section;
              return subsection;
            });
          } else {
            userValues[section].section = section;
            return userValues[section];
          }
        });
        //... and then flatten the array
        sections = _.flattenDeep(valuesArr);
        // process'em all!
        remessa = _.map(sections, (section) => {
          var sectionKey, sectionValues;
          sectionKey = section.section;
          sectionValues = _.omit(section, 'section');
          this.validateLenghts(sectionKey, sectionValues);
          return this.build(this.prepare(sectionKey, sectionValues));
        });
        return removeAccents(remessa.join(newLine) + newLine);
      }

    };

    FILE_HEADER = 'ArquivoHeader';

    FILE_TRAILING = 'ArquivoTrailing';

    LOT_HEADER = 'LoteHeader';

    LOT_TRAILING = 'LoteTrailing';

    DETAIL = 'Detail';

    DETAIL2 = 'Detail2';

    FILE_SECTIONS = [FILE_HEADER, LOT_HEADER, DETAIL, DETAIL2, LOT_TRAILING, FILE_TRAILING];

    return Remessa;

  }).call(this);

  module.exports = Remessa;

}).call(this);
